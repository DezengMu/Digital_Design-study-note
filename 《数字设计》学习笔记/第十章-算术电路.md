## 10.1 二进制数

* 二进制，十六进制，BCD码的**区别** （以十进制转换为例）
  * **二进制**，就是按照类似于“8，4，2，1”的**权重**，将一个十进制表述，所使用的**位宽随十进制数大小而改变**，重点在于突出**数值大小**的概念
  * **十六进制**，是在**二进制的基础上**，将“0，1”代码切分成**4位一组**，用“0-9，A-F"来表示，也有**数值大小**的概念
  * **BCD码**，是在**十进制的基础上**，将一个十进制数的**每一位数字单独表示**，并不关心这一位数字代表的权重，而且严格规定是用**4位二进制数码**表示数字“0-9”，BCD码本身并**没有大小**的概念



## 10.2 二进制加法

* 主要针对《数字设计系统方法》一书P152，图10-5 “全加器的CMOS门级实现”的说明

  * 图10-5 使用“同或”门来实现“异或”门的原因在于：**三个变量的“异或”结果跟“同或”结果是一样的！！！**（见下图）

  * | a    | b    | c    | \^   | ~\^  |
    | :--- | ---- | ---- | ---- | ---- |
    | 0    | 0    | 0    | 0    | 0    |
    | 0    | 0    | 1    | 1    | 1    |
    | 0    | 1    | 0    | 1    | 1    |
    | 0    | 1    | 1    | 0    | 0    |
    | 1    | 0    | 0    | 1    | 1    |
    | 1    | 0    | 1    | 0    | 0    |
    | 1    | 1    | 0    | 0    | 0    |
    | 1    | 1    | 1    | 1    | 1    |




## 10.3 负数和减法电路

* 针对图10-11中，对“减数”连同符号位整个取反的理解
  * 以往在纸上演示二级制减法的时候，总是保留符号位，而是只对其余位取反再+1，于是对于图中的对整个数（包括符号位）取反，有所迷惑，后来经过仔细推敲才得知，问题出现在最开始，对于**“减数”**的理解上
  * 实际上，图10-11的电路是**加/减法单元**，也就是说，同样也是加法电路，而判断是加法还是减法，是通过sub位决定 ，所以，对于整个电路来说，**默认输入的两个运算数其实都是正数**，换句话说，在开始运算前，“减数b”其实还是个正数，**如果需要进行减法运算，则将sub位置为1。此时将”减数b“的符号位与sub异或，得到1（此时相当于b的符号位已经变成1）；再将 b 的剩余位（除符号位以外）取反，加上sub,就完成了”取反+1“的操作**，这个时候才是将 b 真正变成了负数的补码，之后就是补码相加，得到正确的结果。
* 针对表10-3的理解
  * 对于“cis"——代表的是来自剩余位（除符号位以外）的**进位**
    * 如果是加法，如果”cis =1",说明两个运算数都比较大，产生溢出就很正常
    * 如果是减法，因为是**补码**运算，而**补码和对应的原码的大小（单看剩余位的数值大小，不看符号）是相反的**，所以此时如果**“cis = 1"**,说明”减数“的补码偏大，但恰恰说明，”减数“的原码比较小，也就是说**需要减掉的数比较小**，所以不会有溢出；相反，如果**”cis=0"**,说明补码较小 ，原码较大，需要**减去一个较大的数**，自然是有可能溢出的